<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>Waves</title>
	<style>
		* { margin: 0; padding: 0; box-sizing: border-box; }
		html, body { width: 100%; height: 100%; overflow: hidden; background: transparent; }
		#container { width: 100%; height: 100%; }
	</style>
</head>
<body>
	<div id="container"></div>

	<script type="x-shader/x-vertex" id="vertexshader">
		attribute float scale;
		void main() {
			vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
			gl_PointSize = scale * ( 300.0 / - mvPosition.z );
			gl_Position = projectionMatrix * mvPosition;
		}
	</script>
	<script type="x-shader/x-fragment" id="fragmentshader">
		uniform vec3 color;
		void main() {
			if ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 ) discard;
			gl_FragColor = vec4( color, 1.0 );
		}
	</script>

	<script type="importmap">
		{"imports":{"three":"https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js","three/addons/":"https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"}}
	</script>
	<script type="module">
		import * as THREE from 'three';

		const SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;
		let container, camera, scene, renderer;
		let particles, count = 0;
		let mouseX = 520, mouseY = -380;
		let windowHalfX, windowHalfY;

		function init() {
			container = document.getElementById('container');
			windowHalfX = container.clientWidth / 2;
			windowHalfY = container.clientHeight / 2;

			const colorParam = (new URLSearchParams(window.location.search).get('color') || '1296db').replace(/^#/, '');
			const particleColor = new THREE.Color('#'.concat(colorParam.length === 6 ? colorParam : '1296db'));

			camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 1, 10000);
			camera.position.set(520, 380, 2200);
			scene = new THREE.Scene();

			const numParticles = AMOUNTX * AMOUNTY;
			const positions = new Float32Array(numParticles * 3);
			const scales = new Float32Array(numParticles);
			let i = 0, j = 0;
			for (let ix = 0; ix < AMOUNTX; ix++) {
				for (let iy = 0; iy < AMOUNTY; iy++) {
					positions[i] = ix * SEPARATION - ((AMOUNTX * SEPARATION) / 2);
					positions[i + 1] = 0;
					positions[i + 2] = iy * SEPARATION - ((AMOUNTY * SEPARATION) / 2);
					scales[j] = 1;
					i += 3;
					j++;
				}
			}

			const geometry = new THREE.BufferGeometry();
			geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
			geometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));
			const material = new THREE.ShaderMaterial({
				uniforms: { color: { value: particleColor } },
				vertexShader: document.getElementById('vertexshader').textContent,
				fragmentShader: document.getElementById('fragmentshader').textContent
			});
			particles = new THREE.Points(geometry, material);
			scene.add(particles);

			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
			renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
			renderer.setSize(container.clientWidth, container.clientHeight);
			renderer.setAnimationLoop(animate);
			container.appendChild(renderer.domElement);

			container.style.touchAction = 'none';
			container.addEventListener('pointermove', onPointerMove);
			window.addEventListener('resize', onWindowResize);
		}

		function onWindowResize() {
			windowHalfX = container.clientWidth / 2;
			windowHalfY = container.clientHeight / 2;
			camera.aspect = container.clientWidth / container.clientHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(container.clientWidth, container.clientHeight);
		}

		function onPointerMove(event) {
			if (event.isPrimary === false) return;
			mouseX = event.clientX - container.getBoundingClientRect().left - windowHalfX;
			mouseY = event.clientY - container.getBoundingClientRect().top - windowHalfY;
		}

		function animate() {
			camera.position.x += (mouseX - camera.position.x) * 0.05;
			camera.position.y += (-mouseY - camera.position.y) * 0.05;
			camera.lookAt(scene.position);

			const positions = particles.geometry.attributes.position.array;
			const scales = particles.geometry.attributes.scale.array;
			let i = 0, j = 0;
			for (let ix = 0; ix < AMOUNTX; ix++) {
				for (let iy = 0; iy < AMOUNTY; iy++) {
					positions[i + 1] = (Math.sin((ix + count) * 0.3) * 50) + (Math.sin((iy + count) * 0.5) * 50);
					scales[j] = (Math.sin((ix + count) * 0.3) + 1) * 20 + (Math.sin((iy + count) * 0.5) + 1) * 20;
					i += 3;
					j++;
				}
			}
			particles.geometry.attributes.position.needsUpdate = true;
			particles.geometry.attributes.scale.needsUpdate = true;
			renderer.render(scene, camera);
			count += 0.1;
		}

		init();
	</script>
</body>
</html>
